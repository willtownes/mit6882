---
title: "Linear Dynamical System"
author: "Will Townes"
date: "April 21, 2016"
output: html_document
---

```{r}
library(ggplot2)
source("code/func/sampler/lds/lds_util.R")
source("will/util.R")
```

### Linear and Projectile Motion

The linear dynamical system model is given by the following recursive equations:
$$x_t|x_{t-1}\sim\mathcal{N}(A_t x_{t-1},\Sigma_t)$$
$$y_t|x_t\sim\mathcal{N}(C_t x_t,R_t)$$

In Fox et al, they set $C_t=C$ and $R_t=R$ to be constant across time and without loss of generality force $C=[I_d,0]$ where $d$ is the dimensionality of $y_t$. Hence the key parameters that switch are $A_t,\Sigma_t$ and the key parameter that is constant for all time is $R$. 

For the purposes of visualization, we produce data from a projectile trajectory. We follow the discussion in Section 1.3.2 in *Bayesian Time Series Models* by Barber et al. According to a discretization of Newton's Laws of motion, acceleration is constant. Let $q(t)$ be the two-vector of position, $v(t)$ be the velocity vector, and $a=(0,-9.8)$ be the acceleration. If a projectile is launched from the origin $q_0=(0,0)$ with initial velocity $v_0=(10,10)$ (ie the initial angle is $\theta=\pi/4$, we expect it to follow a parabolic path to a maximum height of 
$$y_{max} = \frac{\Vert v_0 \Vert^2\sin^2(\theta)}{2\Vert a\Vert}$$

A discretized version of the trajectory is:
$$q(t+k) = q(t) + k v(t) + \frac{k^2}{2} a$$
$$v(t+k) = v(t) + k a(t) $$
Where $k$ is the time gap between observations (assumed to be constant for simplicity).
Let $x(t) = (q(t),v(t))$ (a 4-vector). We can write $x(t) = A x(t-1) + B$ where
$$A = \begin{pmatrix} I & kI\\0 & I\end{pmatrix}$$
$$B = \begin{pmatrix} \frac{1}{2}k^2 Ia\\ kIa\end{pmatrix}$$
Hence
$$(x_t|x_{t-1})\sim\mathcal{N}\left(Ax_{t-1}+B,\Sigma\right)$$
with $\Sigma$ representing random perturbations in motion due to the wind. We set $\Sigma$ to a a diagonal matrix with diagonal elements $(\sigma^2_1,\sigma^2_1,\sigma^2_2,\sigma^2_2)$. This indicates the noise in the velocity part is different than the position part, but the noise is the same in any spatial direction. This is a linear dynamical system. Assume we observe only a noisy version of the position, $y(t)$. Hence, the observation model is
$$(y_t|x_t)\sim\mathcal{N}\left(Cx_t,R\right)$$
Where $C = (I,0)$ (a 2x4 matrix) and $R$ is measurement noise. We can assume $R$ is an isotropic noise model for simplicity (ie, that it is a scalar times the identity). The simulated data is shown below

```{r}
#parametrize the projectile motion into LDS format
meas_err_sd<-2
pos_noise_sd<-.5
velo_noise_sd<-3
k<-.1 #number of seconds between observations
init_pos<-c(0,0)
init_velo<-c(40,40)
x0<-c(init_pos,init_velo)
Tmax<-10 #number of seconds to run the simulation
iter_max<-floor(Tmax/k)
a<-c(0,-9.8) #acceleration
A<-diag(4)
A[1:2,3:4]<-k*diag(2)
B<-rbind(.5*k^2*diag(2),k*diag(2))%*%a
C<-cbind(diag(2),matrix(0,nrow=2,ncol=2))
Sigma<-diag(c(rep(pos_noise_sd^2,2),rep(velo_noise_sd^2,2)))
R<-meas_err_sd^2*diag(2)
theta<-list()
theta[[1]]<-list(A=A,B=B,Sigma=Sigma)
lambda<-list(C=C,R=R)
z<-rep(1,iter_max)

# simulate and plot a trajectory
xy<-gen_lds(z,x0,theta,lambda) #function from util.R
x<-xy[["x"]]
y<-xy[["y"]]
plot(x[,1],x[,2],type="l",main="Noisy Projectile Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

The projectile motion is a noisy version of a parabolic trajectory. We now illustrate data simulated from a noisy linear trajectory

```{r}
#dynamical parameters for linear motion
theta[[2]]<-list(A=diag(4),B=c(2,1,0,0),Sigma=Sigma)
z<-rep(2,100)
xy<-gen_lds(z,x0,theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
plot(x[,1],x[,2],type="l",main="Noisy Linear Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

### Switching Projectile Motion Inference with Known Dynamical Parameters

The curve indicates the true (discretized) trajectory, the circles represent the noisy observations. The task now is to try to infer the curve given only the circles. We apply the backwards message passing, forwards sampling approach of Fox et al. The backwards message passing algorithm is Algorithm 19 in Fox's thesis. Key functions are defined in util.R. We show some tests of the functions here:

```{r}
#dynamical parameters for linear motion
#theta[[2]]<-list(A=diag(4),B=c(200,20,0,0),Sigma=Sigma)
z<-c(rep(1,50),rep(2,50))
xy<-gen_lds(z,x0,theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
colnames(x)<-c("pos_horiz","pos_vert","velo_horiz","velo_vert")
colnames(y)<-c("pos_horiz","pos_vert")
xs<-rLDS(100,y,z,theta,lambda,x0_return=TRUE) #100 samples from the joint posterior
# munge res into ggplot compatible format
xs<-rLDS_melt(xs,colnames(x))
#plot(xs[,1],xs[,2],col="red")
#lines(x[,1],x[,2],col="blue")
#points(y[,1],y[,2],col="green")
x_true<-as.data.frame(x)
y_obs<-as.data.frame(y)
ggplot(data=xs,aes(x=pos_horiz,y=pos_vert))+geom_path(aes(group=id),colour="grey")+geom_path(data=x_true,aes(colour=factor(z)),size=1.2)+geom_point(data=y_obs,size=1.1)+theme_bw()+xlab("Horizontal Position")+ylab("Vertical Position")+ggtitle("Switching Projectile/Linear Dynamics")
```

In the above plot, the dark line is the true path, the points are the noisy observations, and the gray lines are samples from the posterior. We see that the posterior sampler does a good job capturing the dynamics of the projectile.

```{r}
# save data for use elsewhere
#save(theta,x_true,z,x_0,file="will_dat.RData")
```

### Switching Projectile Motion Inference with Unknown Dynamical Parameters

We now integrate the results from matnorm.Rmd to sample from the conditional distribution of the unknown dynamical parameters. Alternating between this and the trajectory path sample enables inference for the full set of unknown parameters.

```{r}
hyper_init<-function(y,D=ncol(y),hyper=list()){
  #given a matrix of observations "y" (each row is an observation vector) nrow=number of time points
  #specify the desired dimension of the latent state x
  #returns a list of hyperparameters for the matrix normal inverse wishart prior over dynamical parameters
  # the hyperparameters are:
  # S0_df = prior degrees of freedom on Sigma, the transition model covariance/noise
  # S0 = prior scale matrix for Sigma
  # R0_df = prior degrees of freedom on R, the emission model covariance/noise (observation noise)
  # R0 = prior scale matrix for R
  # M_B = (vector) prior mean for additive term B in transition model
  # kappa0 = prior sample size for B
  # M_A = (matrix) prior mean for the transition matrix A of the latent states
  # K_A = inverse of "column covariance" matrix in prior for A
  # Any matching params in the input list "hyper" are returned as-is
  # otherwise, the params are set based on statistics of the observed data y
  # lowess_f only needed for S0 or R0 estimation. Small value=wigglier estimated latent x values
  # large value= more linear latent x values path
  ydim<-ncol(y)
  stopifnot(D>=ydim)
  if(is.null(hyper[["S0_df"]])) hyper[["S0_df"]]<-D+2
  if(is.null(hyper[["R0_df"]])) hyper[["R0_df"]]<-ydim+2
  if(is.null(hyper[["M_B"]])) hyper[["M_B"]]<-rep(0,D)
  if(is.null(hyper[["kappa0"]])) hyper[["kappa0"]]<-.01
  if(is.null(hyper[["M_A"]])) hyper[["M_A"]]<-diag(D)
  if(is.null(hyper[["K_A"]])) hyper[["K_A"]]<-.01*diag(D)
  if(!is.null(hyper[["S0"]]) && !is.null(hyper[["R0"]])) return(hyper)
  S0_df<-hyper[["S0_df"]]
  R0_df<-hyper[["R0_df"]]
  #case where either R0 or S0 not specified, estimate from covariance of data:
  Tmax<-nrow(y)
  time<-1:Tmax
  lowess_f<-60/Tmax #fraction of data points used to estimate x from y, essentially 5 nearest neighbors
  lws_func<-function(u,f){
    # infer latent x column for one of y's columns
    #print(str(u))
    lowess(time,u,f=f)$y
  }
  xhat<-apply(y,2,function(u){lws_func(u,lowess_f)})
  if(is.null(hyper[["R0"]])) hyper[["R0"]]<-cov(y-xhat) #*(R0_df-ydim-1)
  #R0<-hyper[["R0"]]
  #xtrend<-apply(xhat,2,function(u){lws_func(u,20/Tmax)})
  if(is.null(hyper[["S0"]])){
    S0<-matrix(0,nrow=D,ncol=D)
    #S0_topleft<-cov(xhat-xtrend)
    #S0_topleft<-cov(xhat[2:Tmax,]-xhat[1:(Tmax-1),]) 
    S0_topleft<-cov(xhat)
    S0[1:ydim,1:ydim]<-S0_topleft
    S0[(ydim+1):D,(ydim+1):D]<-diag(D-ydim)*det(S0_topleft)/(D-ydim) #formula from E. Fox thesis p. 160
    hyper[["S0"]]<-.01*S0 #*(S0_df-D-1)
  }
  return(hyper)
}
# sample a set of parameters theta from the prior defined by the passed-in hyperparameters
theta_init<-function(hp){
  # hp is a list of hyperparameters (see init_mniw_hyper)
  # this is a sample from the prior for initialization, use bayes_mlinreg_post to sample from full conditional
  Sigma<-riwish(hp$S0_df,hp$S0)
  B<-mvrnorm(1,hp$M_B,Sigma/hp$kappa0)
  A<-rmatnorm(1,hp$M_A,Sigma,hp$K_A,foxpar=TRUE)[[1]]
  return(list(Sigma=Sigma,A=A,B=B))
}
lambda_init<-function(hp){
  # C matrix regarded as fixed and known
  # R matrix random but constant across all dynamical modes
  R<-riwish(hp$R0_df,hp$R0)
  ydim<-ncol(R)
  D<-ncol(hp$S0)
  C<-matrix(0,nrow=ydim,ncol=D)
  C[1:ydim,1:ydim]<-diag(ydim)
  return(list(R=R,C=C))
}
x0_init<-function(x,time=1:10){
  # given other xvalues, initialize x0 by linear extrapolation
  # x is a matrix with each row = an observation vector
  # time is the index vector of observations used to extrapolate to time zero
  x<-x[time,]
  coef(lm(x~time))[1,]
}
```

```{r}
ggbase<-ggplot(data=xs,aes(x=pos_horiz,y=pos_vert))+geom_path(data=x_true,aes(colour=factor(z)),size=1)+geom_point(data=y_obs,size=1.1)+theme_bw()+xlab("Horizontal Position")+ylab("Vertical Position")+ggtitle("Switching Projectile/Linear Dynamics")
theta_true<-theta
K<-2 #number of dynamical modes
D<-4 #latent dimension
hp<-hyper_init(y,D=D) #initialize from default settings based on the data.
#alternatively, set priors by hand
#hp<-list(kappa0=10,S0_df=10,R0_df=10,K_A=10*diag(D),S0=)

#hp$S0<-diag(diag(hp$S0)) #force diagonal
#hp$R0<-diag(diag(hp$R0))
theta_hat<-replicate(K,theta_init(hp),simplify=FALSE)
lambda_hat<-lambda_init(hp)
x_0<-x0_init(x) #cheating here and using the real values, must be a better way?
# D<-4 #dimension of latent state
# ydim<-ncol(y)
# nIter<-nrow(y)
# #use lowess to get a first estimate of latent x values
# xhat_y<-y
# lowess_resid_var<-list()
# for(j in 1:ydim){
#   xhat_y[,j]<-lowess(1:nIter,y[,j],f=.5)[["y"]]
#   lowess_resid_var[[j]]<-mse(y[,j],xhat_y[,j])
# }
# xhat_latent<-matrix(rnorm(nIter*(D-ncol(y))),nrow=nIter)
# xhat<-cbind(xhat_y,xhat_latent) #initialize sampled x
# #split data into chunks based on z and initialize dynamical params "theta"
# theta_hat<-list()
# lambda_hat<-lambda
# for(k in 1:K){
#   z_index<-which(z==k)
#   theta_hat[[k]]<-list()
#   psi<-xhat[z_index,]
#   if(1 %in% z_index){
#     z_index<-z_index[z_index!=1] #omit 1
#     psibar<-rbind(x_0,xhat[z_index-1,]) #previous latent observations
#   } else {
#     psibar<-xhat[z_index-1,]
#   }
#   lm_init<-lm(psi~psibar) #multivariate linreg
#   theta_hat[[k]][["A"]]<-0.5*t(coef(lm_init))[,2:(D+1)]+.5*diag(D)
#   theta_hat[[k]][["B"]]<-0.5*t(coef(lm_init))[,1]
#   theta_hat[[k]][["Sigma"]]<-0.5*diag(unlist(lapply(summary(lm_init),function(x){x$sigma^2})))
# }
# avg_Sigma<-list_mean(theta_hat,function(x){x[["Sigma"]]})
# lambda_hat[["R"]]<-avg_Sigma[1:ydim,1:ydim]
# lambda_hat[["R"]]<-lambda[["R"]] #temporarily pretend this is known
# #set hyperparameters
# Delta0<-.5*diag(rep(lowess_resid_var,2))
# #Delta0<-diag(D)
# #Delta0<-Sigma #pretend this is known
# M_A<-diag(D)
# #M_A<-A #pretend known
# hp<-list(nu0=D+10,kappa0=10,K_A=10*diag(D),Delta0=Delta0)
#now that theta,lambda have been initialized, run Kalman Smoother to sample xhat
for(j in 1:500){
  #lambda[["C"]] regarded as known
  xhat<-rLDS(1,y,z,theta_hat,lambda_hat,x0_return=FALSE)[[1]]
  if(j%%25==0){
    #print(paste("x0=",xhat[1,]))
    xhat_plt<-rLDS_melt(list(xhat),colnames(x))
    #visualize sample trajectory
    show(ggbase+geom_path(data=xhat_plt,linetype=2,aes(group="id")))
  }
  
  #run linear regression sampler on each chunk to update dynamic params
  for(k in 1:K){
    z_index<-which(z==k)
    if(length(z)==nrow(xhat)){ #case that x_0 not first row
      psi<-xhat[z_index,]
      if(1 %in% z_index){
        z_index<-z_index[z_index!=1] #omit 1
        psibar<-rbind(x_0,xhat[z_index-1,]) #previous latent observations
      } else {
        psibar<-xhat[z_index-1,] #previous latent observations
      }
    } else { #case that x_0 included
      psi<-xhat[z_index+1,] #since x_0 is first row
      psibar<-xhat[z_index,]
    }
    theta_hat[k]<-bayes_mlinreg_post(t(psi),t(psibar),hyper=hp,nSample=1)
  }
}
```

After experimenting with different hyperparameter values, we found that a strong prior is essential for stable inference. Otherwise, the dynamic matrices tend to diverge to extreme values. This is likely due to the non-stationarity of the sample path.

### Harmonic Motion with Known Dynamical Parameters

Both the linear and parabolic trajectories have trends. A stationary linear dynamical system is exemplified by harmonic motion (spring motion). To facilitate visualization, we assume a constant rate of horizontal movement with stationary vertical movement defined by the following differential equation:
$$u''(t) = -k \left(u(t)-L\right)$$
Where $k$ is a constant related to material properties of the spring and $L$ is the equilibrium position. This is a one dimensional, second order system for position, and can be represented as a two-dimensional system of first order differential equations.
Converting to the discretized state space model, let $x_t$ be defined as before. We have
$x_t\sim\mathcal{N}(A x_{t-1}+B,\Sigma)$
where
$$A=\begin{pmatrix}1&0&0&0\\0&1&0&\Delta t\\0&0&1&0\\0& -k\Delta t & 0 & 1\end{pmatrix}$$
The constant horizontal motion is achieved by setting $B=(r\Delta t,0,0,k L \Delta t )'$ where $r$ is the fixed horizontal velocity. We now simulate two different harmonic motion patterns, with different values of $k$,$L$, and $r$. We expect that $k$ affects the amplitude while $r$ affects the frequency of the motion. 

```{r eval=FALSE}
k<-.01; L<-100; r<-100
z<-rep(3,1000)
A<-diag(4)
A[2,4]<- 1
A[4,2]<- -k
theta[[3]]<-list(A=A,B=c(r,0,0,k*L),Sigma=3*diag(4))
xy<-gen_lds(z,c(0,L-200,0,0),theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
x_full<-rbind(x_full,x)
y_full<-rbind(y_full,y)
z_full<-c(z_full,z)
plot(x[,1],x[,2],type="l",main="Noisy, Undamped Harmonic Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

This kind of "blowing up" behavior is an artifact of the discretization of the differential equation. It can be improved by using damped harmonic motion:
$$u''(t) = -k u(t) - \delta u'(t)$$
The $\delta$ parameter causes the acceleration to tend toward zero. In terms of the linear dynamical system representation, this corresponds with replacing the one on the diagonal with $1-\delta$ in the fourth position (the vertical velocity position).

```{r eval=FALSE}
k<-.01; L<-100; r<-100; delta<-2
z<-rep(3,1000)
A<-diag(4)
A[2,4]<- 1
A[4,2]<- -k
A[4,4]<- 1-delta
theta[[3]]<-list(A=A,B=c(r,0,0,k*L),Sigma=3*diag(4))
xy<-gen_lds(z,c(0,L-200,0,0),theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
x_full<-rbind(x_full,x)
y_full<-rbind(y_full,y)
z_full<-c(z_full,z)
plot(x[,1],x[,2],type="l",main="Noisy, Damped Harmonic Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

### Harmonic Motion with Unknown Dynamical Parameters