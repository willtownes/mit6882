---
title: "Linear Dynamical System"
author: "Will Townes"
date: "April 21, 2016"
output: html_document
---

```{r}
library(ggplot2)
source("util.R") #all LDS functions defined here
```

### Linear and Projectile Motion

The linear dynamical system model is given by the following recursive equations:
$$x_t|x_{t-1}\sim\mathcal{N}(A_t x_{t-1},\Sigma_t)$$
$$y_t|x_t\sim\mathcal{N}(C_t x_t,R_t)$$

In Fox et al, they set $C_t=C$ and $R_t=R$ to be constant across time and without loss of generality force $C=[I_d,0]$ where $d$ is the dimensionality of $y_t$. Hence the key parameters that switch are $A_t,\Sigma_t$ and the key parameter that is constant for all time is $R$. 

For the purposes of visualization, we produce data from a projectile trajectory. We follow the discussion in Section 1.3.2 in *Bayesian Time Series Models* by Barber et al. According to a discretization of Newton's Laws of motion, acceleration is constant. Let $q(t)$ be the two-vector of position, $v(t)$ be the velocity vector, and $a=(0,-9.8)$ be the acceleration. If a projectile is launched from the origin $q_0=(0,0)$ with initial velocity $v_0=(10,10)$ (ie the initial angle is $\theta=\pi/4$, we expect it to follow a parabolic path to a maximum height of 
$$y_{max} = \frac{\Vert v_0 \Vert^2\sin^2(\theta)}{2\Vert a\Vert}$$

A discretized version of the trajectory is:
$$q(t+k) = q(t) + k v(t) + \frac{k^2}{2} a$$
$$v(t+k) = v(t) + k a(t) $$
Where $k$ is the time gap between observations (assumed to be constant for simplicity).
Let $x(t) = (q(t),v(t))$ (a 4-vector). We can write $x(t) = A x(t-1) + B$ where
$$A = \begin{pmatrix} I & kI\\0 & I\end{pmatrix}$$
$$B = \begin{pmatrix} \frac{1}{2}k^2 Ia\\ kIa\end{pmatrix}$$
Hence
$$(x_t|x_{t-1})\sim\mathcal{N}\left(Ax_{t-1}+B,\Sigma\right)$$
with $\Sigma$ representing random perturbations in motion due to the wind. We set $\Sigma$ to a a diagonal matrix with diagonal elements $(\sigma^2_1,\sigma^2_1,\sigma^2_2,\sigma^2_2)$. This indicates the noise in the velocity part is different than the position part, but the noise is the same in any spatial direction. This is a linear dynamical system. Assume we observe only a noisy version of the position, $y(t)$. Hence, the observation model is
$$(y_t|x_t)\sim\mathcal{N}\left(Cx_t,R\right)$$
Where $C = (I,0)$ (a 2x4 matrix) and $R$ is measurement noise. We can assume $R$ is an isotropic noise model for simplicity (ie, that it is a scalar times the identity). The simulated data is shown below

```{r}
#parametrize the projectile motion into LDS format
meas_err_sd<-500
pos_noise_sd<-10
velo_noise_sd<-40
k<-.5 #number of seconds between observations
init_pos<-c(0,0)
init_velo<-c(250,250)
x0<-c(init_pos,init_velo)
Tmax<-60 #number of seconds to run the simulation
iter_max<-floor(Tmax/k)
a<-c(0,-9.8) #acceleration
A<-diag(4)
A[1:2,3:4]<-k*diag(2)
B<-rbind(.5*k^2*diag(2),k*diag(2))%*%a
C<-cbind(diag(2),matrix(0,nrow=2,ncol=2))
Sigma<-diag(c(rep(pos_noise_sd^2,2),rep(velo_noise_sd^2,2)))
R<-meas_err_sd^2*diag(2)
theta<-list()
theta[[1]]<-list(A=A,B=B,Sigma=Sigma)
lambda<-list(C=C,R=R)
z<-rep(1,iter_max)

# simulate and plot a trajectory
xy<-gen_lds(z,x0,theta,lambda) #function from util.R
x<-xy[["x"]]
y<-xy[["y"]]
plot(x[,1],x[,2],type="l",main="Noisy Projectile Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

The projectile motion is a noisy version of a parabolic trajectory. We now illustrate data simulated from a noisy linear trajectory

```{r}
#dynamical parameters for linear motion
theta[[2]]<-list(A=diag(4),B=c(5,5,0,0),Sigma=Sigma)
lambda0<-lambda
lambda[["R"]]<-R/100
z<-rep(2,100)
xy<-gen_lds(z,x0,theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
plot(x[,1],x[,2],type="l",main="Noisy Linear Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

### Switching Projectile Motion Inference with Known Dynamical Parameters

The curve indicates the true (discretized) trajectory, the circles represent the noisy observations. The task now is to try to infer the curve given only the circles. We apply the backwards message passing, forwards sampling approach of Fox et al. The backwards message passing algorithm is Algorithm 19 in Fox's thesis. Key functions are defined in util.R. We show some tests of the functions here:

```{r}
#dynamical parameters for linear motion
theta[[2]]<-list(A=diag(4),B=c(100,5,0,0),Sigma=Sigma)
lambda<-lambda0
z<-c(rep(1,100),rep(2,100))
xy<-gen_lds(z,x0,theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
colnames(x)<-c("pos_horiz","pos_vert","velo_horiz","velo_vert")
colnames(y)<-c("pos_horiz","pos_vert")
xs<-rLDS(100,y,z,theta,lambda) #100 samples from the joint posterior
# munge res into ggplot compatible format
xs<-rLDS_melt(xs,colnames(x))
#plot(xs[,1],xs[,2],col="red")
#lines(x[,1],x[,2],col="blue")
#points(y[,1],y[,2],col="green")
x_true<-as.data.frame(x)
y_obs<-as.data.frame(y)
ggplot(data=xs,aes(x=pos_horiz,y=pos_vert))+geom_path(aes(group=id),colour="grey")+geom_path(data=x_true,aes(colour=factor(z)),size=1.2)+geom_point(data=y_obs,size=1.1)+theme_bw()+xlab("Horizontal Position")+ylab("Vertical Position")+ggtitle("Switching Projectile/Linear Dynamics")
```

In the above plot, the dark line is the true path, the points are the noisy observations, and the gray lines are samples from the posterior. We see that the posterior sampler does a good job capturing the dynamics of the projectile.

```{r}
x_0<-c(-5,-5,250,250)
# save data for use elsewhere
#save(theta,x_true,z,x_0,file="will_dat.RData")
```

### Switching Projectile Motion Inference with Unknown Dynamical Parameters

We now integrate the results from matnorm.Rmd to sample from the conditional distribution of the unknown dynamical parameters. Alternating between this and the trajectory path sample enables inference for the full set of unknown parameters.

```{r}
ggbase<-ggplot(data=xs,aes(x=pos_horiz,y=pos_vert))+geom_path(data=x_true,aes(colour=factor(z)),size=1.2)+geom_point(data=y_obs,size=1.1)+theme_bw()+xlab("Horizontal Position")+ylab("Vertical Position")+ggtitle("Switching Projectile/Linear Dynamics")
theta_true<-theta
K<-2 #number of dynamical modes
D<-4 #dimension of latent state
ydim<-ncol(y)
nIter<-nrow(y)
xhat_latent<-matrix(rcauchy(nIter*(D-ncol(y))),nrow=nIter)
xhat<-cbind(y,xhat_latent) #initialize sampled x
#split data into chunks based on z and initialize dynamical params "theta"
theta_hat<-list()
lambda_hat<-lambda
for(k in 1:K){
  z_index<-which(z==k)
  theta_hat[[k]]<-list()
  psi<-xhat[z_index,]
  if(1 %in% z_index){
    z_index<-z_index[z_index!=1] #omit 1
    psibar<-rbind(x_0,xhat[z_index-1,]) #previous latent observations
  } else {
    psibar<-xhat[z_index-1,]
  }
  lm_init<-lm(psi~psibar) #multivariate linreg
  theta_hat[[k]][["A"]]<-0.5*t(coef(lm_init))[,2:(D+1)]+.5*diag(D)
  theta_hat[[k]][["B"]]<-0.5*t(coef(lm_init))[,1]
  theta_hat[[k]][["Sigma"]]<-0.5*diag(unlist(lapply(summary(lm_init),function(x){x$sigma^2})))
}
avg_Sigma<-list_mean(theta_hat,function(x){x[["Sigma"]]})
lambda_hat[["R"]]<-avg_Sigma[1:ydim,1:ydim]

#now that theta,lambda have been initialized, run Kalman Smoother to sample xhat

#set hyperparameters for prior, these are adaptively updated later by empirical bayes
# nu0=D+2
# var_est<-mean(diag(cov(y)))
# Delta0=.75*var_est*diag(D) #rough estimate
# kappa0=.01
# M_A<-matrix(0,nrow=D,ncol=D)
# M_B<-rep(0,D)
# K_A<-diag(rep(.1,D))

#initialize dynamical parameters with samples from prior
# for(k in 1:K){
#   theta[[k]][["Sigma"]]<-Sigma<-riwish(nu0,Delta0)
#   theta[[k]][["A"]]<-rmatnorm(1,M_A,Sigma,K_A,foxpar=TRUE)[[1]]
#   theta[[k]][["B"]]<-mvrnorm(1,M_B,Sigma/kappa0)
# }

#lambda[["C"]] regarded as known
xhat<-rLDS(1,y,z,theta_hat,lambda_hat)
xhat_plt<-rLDS_melt(xhat,colnames(x))
#visualize sample trajectory
ggbase+geom_path(data=xhat_plt,colour="grey",aes(group="id"))

#run linear regression sampler on each chunk
#bayes_mlinreg_post(Y,X)
#run kalman smoother/sampler

# munge res into ggplot compatible format
xhat<-
```

### Harmonic Motion with Known Dynamical Parameters

Both the linear and parabolic trajectories have trends. A stationary linear dynamical system is exemplified by harmonic motion (spring motion). To facilitate visualization, we assume a constant rate of horizontal movement with stationary vertical movement defined by the following differential equation:
$$u''(t) = -k \left(u(t)-L\right)$$
Where $k$ is a constant related to material properties of the spring and $L$ is the equilibrium position. This is a one dimensional, second order system for position, and can be represented as a two-dimensional system of first order differential equations.
Converting to the discretized state space model, let $x_t$ be defined as before. We have
$x_t\sim\mathcal{N}(A x_{t-1}+B,\Sigma)$
where
$$A=\begin{pmatrix}1&0&0&0\\0&1&0&\Delta t\\0&0&1&0\\0& -k\Delta t & 0 & 1\end{pmatrix}$$
The constant horizontal motion is achieved by setting $B=(r\Delta t,0,0,k L \Delta t )'$ where $r$ is the fixed horizontal velocity. We now simulate two different harmonic motion patterns, with different values of $k$,$L$, and $r$. We expect that $k$ affects the amplitude while $r$ affects the frequency of the motion. 

```{r eval=FALSE}
k<-.01; L<-100; r<-100
z<-rep(3,1000)
A<-diag(4)
A[2,4]<- 1
A[4,2]<- -k
theta[[3]]<-list(A=A,B=c(r,0,0,k*L),Sigma=3*diag(4))
xy<-gen_lds(z,c(0,L-200,0,0),theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
x_full<-rbind(x_full,x)
y_full<-rbind(y_full,y)
z_full<-c(z_full,z)
plot(x[,1],x[,2],type="l",main="Noisy, Undamped Harmonic Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

This kind of "blowing up" behavior is an artifact of the discretization of the differential equation. It can be improved by using damped harmonic motion:
$$u''(t) = -k u(t) - \delta u'(t)$$
The $\delta$ parameter causes the acceleration to tend toward zero. In terms of the linear dynamical system representation, this corresponds with replacing the one on the diagonal with $1-\delta$ in the fourth position (the vertical velocity position).

```{r eval=FALSE}
k<-.01; L<-100; r<-100; delta<-2
z<-rep(3,1000)
A<-diag(4)
A[2,4]<- 1
A[4,2]<- -k
A[4,4]<- 1-delta
theta[[3]]<-list(A=A,B=c(r,0,0,k*L),Sigma=3*diag(4))
xy<-gen_lds(z,c(0,L-200,0,0),theta,lambda)
x<-xy[["x"]]
y<-xy[["y"]]
x_full<-rbind(x_full,x)
y_full<-rbind(y_full,y)
z_full<-c(z_full,z)
plot(x[,1],x[,2],type="l",main="Noisy, Damped Harmonic Motion",xlab="Horizontal Position",ylab="Vertical Position")
points(y[,1],y[,2])
```

### Harmonic Motion with Unknown Dynamical Parameters